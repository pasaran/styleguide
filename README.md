# Styleguide для JavaScript'а

Основное положение: экономить байты в коде должен обфускатор,
а код должен быть максимально читаемым и понятным.


## Общие положения

  * Кодировка файлов — utf-8;

  * Переводы строк — unix style;

  * Индент — 4 пробела;

  * Не забываем удалять "висящие" пробелы, т.е. те, после которых нет непробельных символов.

  * Всегда явно ставим `;`, не полагаясь на automatic semicolon insertion.


## Блоки кода `{...}`

Открывающая `{` расположена на той же строке, что и оператор, к которому она относится.

    //  Плохо:
    if (expr)
    {
        ...
    }

    //  Хорошо:
    if (expr) {
        ...
    }

Закрывающая `}` выровнена по открывающему оператору (внутренняя по `while`, внешняя по `if` в данном случае):

    if (expr) {
        while (i < 10) {
            ...
        }
    }

Перед открывающей `{` всегда ставится пробел.


## Оператор `if`

Тело `if` всегда в фигурных скобках:

    //  Плохо.
    if (...) doSomething();
    if (...) return;

    //  Хорошо.
    if (...) {
        doSomething();
    }
    if (...) { return; }

После `{` почти всегда должен быть перевод строки.
Допустимые исключения:

    //  Можно.
    if (...) { return; }
    if (...) { continue; }
    if (...) { break; }

    //  Плохо.
    if (...) { doSomething(); }

Однострочный `if` с `else` запрещен в любых ситуациях:

    //  Плохо.
    if (...) { first(); } else { second(); }

    //  Хорошо.
    if (...) {
        first();
    } else {
        second();
    }

Между `if` и `(` всегда пробел:

    //  Плохо.
    if(expr) {
        ...
    }

`else` на той же строке, что и `}` первого блока, перед `else` — пробел, перед `{` — пробел:

    //  Плохо.
    if (expr) {
        ...
    }
    else {
        ...
    }

`else if` оформляется по тем же правилам, что и `else`:

    if (expr) {
        ...
    } else if (expr) {
        ...
    }

    if (expr1) {
        ...
    } else if (expr2) {
        ...
    } else if (expr3) {
        ...
    } else {
        ...
    }


## Оператор `while`

Между `while` и `(` — всегда пробел:

    //  Плохо.
    while(expr) {
        ...
    }

    //  Хорошо.
    while (expr) {
        ...
    }

## Цикл `do`

Не используем.

## Оператор `for`

Между `for` и `(` — пробел, перед `{` — пробел.
Если переменные `i` и `l` не используются нигде, кроме тела цикла, то определяем их внутри:

    for (var i = 0, l = a.length; i < l; i++) {
        ...
    }

Если же переменные цикла используются и за пределами блока, то определяем их отдельно:

    var i, l;

    for (i = 0, l = a.length; i < l; i++) {
        ...
    }

    if (i > 5) {
        ...
    }

При этом нормально определять и использовать одни и те же переменные внутри
нескольких циклов:

    for (var i = 0, l = a.length; i < l; i++) {
        ...
    }

    //  Да, формально i и l в JavaScript'е тут уже определены,
    //  но мы притворяемся, что у нас блочный scope.
    for (var i = 0, l = a.length; i < l; i++) {
        ...
    }


## Вызов функции

Между именем функции и `(` нет пробела.

    var a = f(1, 2) + g();


## Определение функции

Между `function` и именем функции — пробел (очевидно), между именем функции и `(` — нет пробела:

    function name() {
        ...
    }

    function name(arg) {
        ...
    }

В случае анонимной функции, ключевое слово `function` в каком-то смысле выполняет роль имени,
поэтому между `function` и `(` нет пробела:

    function() {
        ...
    }

Между `function` и `(` пробела по-прежнему нет, перед запятой никогда нет пробела, после — всегда есть.

    function(arg1, arg2) {
        ...
    }


## Выражения

Все бинарные операции (присваивания, сравнения, арифметические и т.д.) всегда отбиваются пробелами с двух сторон:

    var a = 1;

    if (a == b || a > 1) {
        ...
    }

Все унарные операции (унарный минус, инкременты, и т.д.) никогда не отбиваются пробелами:

    if (!a && -a < 3 || ~a) {
        i++;
    }

Скобки добавляем, если выражение сложное и приоритеты не читаются сразу. Но без фанатизма:

    var a = b || c && d > 0 || b == 0;
    var a = (b || c) && (d > 0 || b) == 0;
    var a = b || (c && (d > 0)) || (b == 0);

При сравнении выражения с константой, слева — выражение, справа — константа.

    if (1 == a && true !== f(a)) { // Плохо
        ...
    }

    if (a == 1 && f(a) !== true) { // Хорошо
        ...
    }


## `==` vs. `===`

Всегда используем `===`:

    if (typeof obj === "string") {
        ...
    }

За исключением одного случая, когда нужно проверить, не является ли значение `null` или `undefined`.

    if (value == null) { // Или value == undefined.
        ...
    }


## Определение переменных

Каждая переменная заслуживает своего личного `var`:

    //  Плохо.
    var i = 0,
        result = {},
        list = [];

    //  Хорошо.
    var i = 0;
    var result = {};
    var list = [];

Единственное исключение: набор однородных и связанных
(т.е. эти переменные для одного и того же и не могут использоваться порознь)
переменных, без инициализации. Например:

    var i, j, k;
    for (i = 0; i < 10; i++) {
        for (j = 0; j < 10; j++) {
            for (k = 0; k < 10; k++) {
                ...

    var i, l;
    for (var i = 0, l = a.length; i < l; i++) {
        ...
    }

То есть более-менее это переменные для итерации.

Если переменные не связаны (даже если нет инициализации),
нужно использовать отдельные `var`:

    var id;
    var is_foo;

Не нужно выравнивать значения переменных в столбик:

    //  Плохо.
    var id =            42;
    var title =         'Hello';
    var is_something =  true;

    //  Плохо.
    var id              = 42;
    var title           = 'Hello';
    var is_something    = true;

    //  Хорошо.
    var id = 42;
    var title = 'Hello';
    var is_something = true;

Переменные определяются по месту использования, а не вначале scope'а.
При этом считаем, что у нас блочный scope (на самом деле в JavaScript это не так).

    //  Плохо.
    if (...) {
        var i = 10;
        ...

    }

    //  Ошибка!
    //  Запрещается использовать переменную вне блока,
    //  в котором она определена.
    var j = i + 1;


    //  Хорошо.
    var i;
    if (...) {
        i = 10;
        ...
    }

    var j = i + 1;


## Имена для переменных, функций, классов и т.д.

  * С большой буквы — названия классов и миксинов, с маленькой — все остальное;

  * Используем `camelCase`, а не `under_score_style`.
    Редкие исключения: переменные с суффиксом типа `_id`:

        var model_id = ...; // modelId плохо читается.

    **Подумать:** не стоит ли в названиях переменных использовать `under_score_style`?

  * "Приватные" переменные: `_privateVariable`.


## Тернарный оператор

Условие в скобках, вокруг `?` и `:` — пробелы:

    var x = (a > 0) ? 1 : 0;

Вложенные тернарные операторы запрещены.

    //  Плохо.
    var r = (a > 0) ? (b > 0) ? a : b : 0;

    //  Хорошо.
    var r;
    if (a > 0) {
        r = (b > 0) ? a : b;
    } else {
        r = 0;
    }

    //  Хорошо.
    var r;
    if (a > 0) {
        if (b > 0) {
            r = a;
        } else {
            r = b;
        }
    } else {
        r = 0;
    }

Да, многословно, зато читаемо без вопросов.

    //  Хорошо.
    //  Вычисляем что-то там.
    var t = (b > 0) ? a : b;
    var r = (a > 0) ? t : 0;


## `if` vs. тернарный оператор, `&&`, `||`

Да, JavaScript позволяет использовать тернарный оператор в качестве замены `if`:

    (a > 0) ? f() : g();

    (a > 0) && f();

    (a > 0) || g();

Но это **дурной тон**. Никогда-никогда так не делаем.

Не ленимся, не экономим байты и используем `if`:

    if (a > 0) {
        f();
    } else {
        g();
    }

    if (a > 0) {
        f();
    }

    if (!(a > 0)) {
        g();
    }

Правило очень простое.
Если блок не возвращает значение или же мы это значение игнорируем, то всегда используется `if`.
Тернарный оператор, `&&` и `||` могут использоваться как часть выражения, возвращаюшего значение:

    a = b && c;
    b = (a > 0) || true;
    c = (a > 0) ? 2 : f();


## Комментарии

Желательно использовать инлайновые комментарии, а не блочные.
Причина простая: код, в котором есть блочные комментарии,
невозможно легко и просто закомментировать.
А инлайновые комментарии этому не мешают.

После `//` добавляем **два** пробела.
Причина: комментарии в этом случае выравниваются "по сетке".
В комментариях используем `markdown`.

    //  Комментарий, относящийся к блоку кода.
    //
    function a() {
        //  Поясняем конкретную строку.
        if (x > 0) {
            ...
        }

        //  Коммент про блок кода.
        //  Многострочный и многословный.
        //
        //  Считаем, что комментарии написаны с использованием `markdown`:
        //
        //      for (var i = 0; i < 10; i++) {
        //          ...
        //      }
        //
        for (var i = 0; i < 10; i++) {
            ...
        }
    }

Блочные комментарии всегда располагаем на отдельной строке.

**Плохо**

    /* function a() {
        ...
    } */

Хорошо:

    /*
    function a() {
        ...
    }
    */


## Кавычки

Всегда используем одинарные кавычки:

    // Во-первых, удобнее набирать — не нужно нажимать шифт.
    var msg = 'Hello, World!';

    // Во-вторых, в html'ных фрагментах можно использовать двойные кавычки и не эскейпить их.
    var html = '<div class="hello">Hello, World</div>';


## Именование сущностей

### Константы

Используем ALL_CAPS стиль:

    var PI = 3.1415;

    //  В этом случае `no.View` это неймспейс,
    //  а `STATUS.OK` — название константы.
    //
    no.View.STATUS.OK = 'ok';

### Конструкторы

Название конструктора всегда начинается с заглавной буквы.
Используем CamelCase:

    function View() {
        ...
    }

    function ViewCollection() {
        ...
    }

### Приватные свойства и методы объекта

Используем префикс `_`:

    function Foo(data) {
        this._data = data;
    }

### Переменные

Используем underscore_style.

### Методы

    model.getData()

    this.buildHtmlTree()

### `jQuery`-объекты

Используем префикс `$` для jquery-объектов:

    var $node = $(node);

Это позволяет нам избегать ошибок типа:

    $($node).find(...)


## Не определять методы внутри object literal

    //  Плохо.
    var obj = {
        getData: function() {
            return this.data;
        },
        ...
    };

    //  Хорошо.
    var obj = {};

    obj.getData = function() {
        return this.data;
    };

Тоже самое, при использовании разных фабрик объектов:

    //  Плохо.
    ns.View.define('message', {
        events: {
            'changed': function() {
                ...
            },
            ...
        },

        methods: {
            'onclick': function() {
                ...
            },
            ...
        }
    });


    //  Хорошо.
    var events = {};

    events.changed = function() {
        ...
    };

    var methods = {};

    methods.onclick = function() {
        ...
    };

    ns.View.define('message', {
        events: events,
        methods: methods
    });


    //  Еще лучше.
    var message = {};

    message.events = {};

    message.events.changed = function() {
        ...
    };

    message.methods = {};

    message.methods.onclick = function() {
        ...
    };

    ns.View.define('message', message);

## `var that = this;`

Стандартный "заменитель" для `this` — `that`:

    var that = this;

    doAsync(function() {
        that.doSomething();
    });


## Не использовать `bind`

## По возможности не использовать `call` и `apply`

## Object literal

В однострочном объекте отбиваем содержимое от скобок пробелом.
После двоеточия всегда пробел, перед — нет пробела.

    //  Плохо.
    {id: 42, title: 'Hello'}

    //  Хорошо.
    { id: 42, title: 'Hello' }

Многострочный объект. Запятая в конце строки.

    {
        id: 42,
        title: 'Hello'
    }

Никогда не выравниваем значения в столбик:

    //  Плохо.
    {
        id:    42,
        title:  'Hello'
    }

(Спорно) В случае, когда некоторые ключи нужно кавычить, лучше делать это для всех ключей.
Даже для тех, для которых это не нужно:

    //  Не очень хорошо.
    {
        id: 42,
        'category-id': 'life',
        'post-title': 'Hello'
    }

    //  Лучше.
    {
        'id': 42,
        'category-id': 'life',
        'post-title': 'Hello'
    }


## Array literal

В однострочном массиве отбиваем содержимое от скобок пробелом.
После запятой всегда пробел, перед запятой нет пробела:

    //  Плохо.
    [1, 2, 3]

    //  Хорошо.
    [ 1, 2, 3 ]

Многострочный массив:

    [
        1,
        2,
        3
    ]

В многострочном массиве каждое значение на отдельной строке:

    //  Не очень хорошо.
    [
        1, 2, 3,
        4,
        5
    ]

Но возможен вариант а-ля матрица:

    [
        1, 2, 3,
        4, 5, 6,
        7, 8, 9
    ]

## Присваивание в выражении

Не очень хорошая идея, но иногда бывает удобно использовать результат
присваивания в качестве выражения.
В этом случае присваивание оборачивается в `(( ... ))`.
Это говорит нам, что это не ошибка, что здесь не предполагается `==`,
а это явное присваивание:

    //  Плохо.
    if ( data = this.getData() ) {
        ...
    }

    //  Хорошо.
    if (( data = this.getData() )) {
        ...
    }


## Chaining

    function quote(s) {
        return s
            .toString()
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
    }

## HRule

Для визуального разбиения кода на части используется вот такой разделитель:

    function foo() {
        ...
    }

    //  ---------------------------------------------------------------------------------------------------------------  //

    function bar() {
        ...
    }

Его длина — 119 символов (не спрашивайте).
Обратите внимание, по два пробела после и перед `//`.

Сверху и снизу отбивается пустой строкой.

Можно использовать для "заголовков", начинающих большую секцию кода:

    //  ---------------------------------------------------------------------------------------------------------------  //
    //  no.View
    //  ---------------------------------------------------------------------------------------------------------------  //

    no.View = function() {
        ...
    };

    //  ---------------------------------------------------------------------------------------------------------------  //

    no.View.prototype.foo = function() {
        ...
    };

    no.View.prototype.bar = function() {
        ...
    };



    //  ---------------------------------------------------------------------------------------------------------------  //

Внутри секции используется опять-таки разделитель, а перед последним стоит не одна пустая строка,
а две-три, чтобы подчеркнуть, что секция тут заканчивается.

## Присваивание выражения со сравнениями

Используем скобки, чтоб явно отделить выражение от присваивания:

    //  Плохо.
    var a = b > 0;
    var c = d === e;
    var x = y > 0 && z < 0;

    //  Хорошо.
    var a = (b > 0);
    var c = (d === e);
    var x = (y > 0 && z < 0);

При этом можно писать и так:

    var is_foo = foo && bar;

и так:

    var is_foo = (foo && bar);

## Обертка для модуля

Часто весь модуль заворачивается в `IIFE`,
чтобы не засорять глобальный контекст:

    //  Неймспейс.
    var ns = {};

    (function() {

    //  ---------------------------------------------------------------------------------------------------------------  //

    //  Глобальные переменные модуля,
    //  которые не должны засорять общий глобальный контекст.
    //
    var id = 42;

    ns.foo = function() {
        ...
    }

    //  ---------------------------------------------------------------------------------------------------------------  //

    })();

При этом содержимое модуля не индентится.
Только в этом случае — когда это на самом верхнем уровне файла.

Вот здесь уже должен быть индент, т.к. здесь это не wrapper модуля, а просто обертка для замыкания:

    var results = [];
    for (var i = 0; i < 10; i++) {
        (function(i) {
            //  Должен быть индент.
            get(function(result) {
                results[i] = result;
            });
        })(i);
    }

