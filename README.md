# Styleguide для JavaScript'а

Основное положение: экономить байты в коде должен обфускатор,
а код должен быть максимально читаемым и понятным.


## Общие положения

  * Кодировка файлов — utf-8;

  * Переводы строк — unix style;

  * Индент — 4 пробела;

  * Не забываем удалять "висящие" пробелы, т.е. те, после которых нет непробельных символов.

  * Всегда явно ставим `;`, не полагаясь на automatic semicolon insertion.


## Спорные вещи

Есть кое-какие моменты, которые я почти готов внести в styleguide, даже несмотря на то,
что мне пока не очень нравятся эти изменения. Или не до конца нравятся.

В частности:

  * Использовать `under_score_style` для всех переменных и функций.
    Для конструкторов — `Under_Score_Style`.
    Для методов — `under_Score_Style` (хотя, возможно, и просто `under_score_style`).

    Причина. Подчеркивание намного более читаемо в качестве разделителя слов.
    Слова в `camelCase` и `CamelCase` сливаются в кашу.

    Сравните:

        'getElementById'        'get_element_by_id'         'get_Element_By_Id'
        'buildHTMLTree'         'build_html_tree'           'build_HTML_Tree'

    Да, подчеркивание непривычно (для javascript'а, хотя вполне привычно в C).
    Но зато решает задачу читаемости.

  * Всегда отбивать пробелами изнутри круглые скобки:

        if ( x ) {
            ...
        }

        foo( x, y )

    Причина. Текущее правило таково, что отбивка нужна, если внутри скобок есть другие скобки.
    (более мягкий вариант, если есть рядом стоящие скобки, например '))' или '])' и т.д.

        //  Плохо.
        foo(bar(), quu())

        //  Хорошо.
        foo( bar(), quu() )

    Но. Предположим, что у нас есть такой код:

        foo(x, y)

    Раз внутри скобок нет, то вроде отбивка не нужна.
    Но вот мы решили добавить еще аргумент (или поменять существующий):

        foo(x, y, z() )

    Потом приходится идти к первой скобке и ставить пробел там.
    Кажется, что лучше сразу ставить пробелы везде и не мучиться потом.
    Опять-таки непривычно, но консистентно.

    Кроме того, часто бывает вот такой какой-то код:

        if ( ... ) {
            //  `x` на разных строчках выравнен по разному.
            foo(x);
        } else {
            foo( x, y() );
        }

        //  Лучше.
        if ( ... ) {
            foo( x );
        } else {
            foo( x, y() );
        }


## Блоки кода `{...}`

Открывающая `{` расположена на той же строке, что и оператор, к которому она относится.

    //  Плохо:
    if ( ... )
    {
        ...
    }

    //  Хорошо:
    if ( ... ) {
        ...
    }

Закрывающая `}` выровнена по открывающему оператору (внутренняя по `while`, внешняя по `if` в данном случае):

    if ( ... ) {
        while ( ... ) {
            ...
        }
    }

Перед открывающей `{` всегда ставится пробел.

Однострочные блоки кода почти всегда запрещены:

    //  Плохо.
    while ( i < 10 ) { doSomething( i ); }

    //  Хорошо.
    while ( i < 10 ) {
        doSomething( i );
    }

Единственное исключение:

    ... { return; }
    ... { continue; }
    ... { break; }


## Оператор `if`

  * Между `if` и `(` — пробел.
  * Между `)` и `{` — пробел.
  * Выражение внутри `( ... )` отбито пробелами.

<!---->

    //  Плохо.
    if(i > 0){
        ...
    }

    //  Хорошо.
    if ( i > 0 ) {
        ...
    }

Тело `if` всегда в фигурных скобках:

    //  Плохо.
    if ( ... ) doSomething();
    if ( ... ) return;

    //  Хорошо.
    if ( ... ) {
        doSomething();
    }
    if ( ... ) { return; }

После `{` почти всегда должен быть перевод строки.
Допустимые исключения:

    //  Можно.
    if ( ... ) { return; }
    if ( ... ) { continue; }
    if ( ... ) { break; }

    //  Плохо.
    if ( ... ) { doSomething(); }

Однострочный `if` с `else` запрещен в любых ситуациях:

    //  Плохо.
    if ( ... ) { first(); } else { second(); }

    //  Хорошо.
    if ( ... ) {
        first();
    } else {
        second();
    }

`else` на той же строке, что и `}` первого блока, перед `else` — пробел, перед `{` — пробел:

    //  Плохо.
    if ( ... ) {
        ...
    }
    else {
        ...
    }

    //  Хорошо.
    if ( ... ) {
        ...
    } else {
        ...
    }

`else if` оформляется по тем же правилам, что и `else`:

    if ( ... ) {
        ...
    } else if ( ... ) {
        ...
    }

    if ( ... ) {
        ...
    } else if ( ... ) {
        ...
    } else if ( ... ) {
        ...
    } else {
        ...
    }


## Оператор `while`

  * Между `while` и `(` — пробел.
  * Между `)` и `{` — пробел.
  * Выражение в `( ... )` отбивается пробелами.
  * После `{` — перевод строки.

<!---->

    //  Плохо.
    while(i < 10){
        doSomething(i);
    }

    //  Плохо.
    while ( i < 10 ) { doSomething( i ); }

    //  Хорошо.
    while ( i < 10 ) {
        doSomething( i );
    }


## Цикл `do`

  * Между `do` и `{` — пробел.
  * Между `}` и `while` — пробел.
  * Между `while` и `(` — пробел.
  * Выражение в `( ... )` отбивается пробелами.
  * После `{` — перевод строки.

<!---->

    //  Плохо.
    do{
        doSomething(i++);
    }while(i < 10);

    do { doSomething(i++); } while ( i < 10 );

    //  Хорошо.
    do {
        doSomething( i++ );
    } while ( i < 10 );

Вообще говоря, я предпочитаю не пользоваться этим циклом вообще.
Мне больше нравится более явный цикл `while`:

    while ( true ) {
        doSomething( i++ );

        if ( i >= 10 ) { break; }
    }


## Оператор `for`

  * Между `for` и `(` — пробел.
  * Между `)` и `{` — пробел.
  * Содержимое внутри `( ... )` отбивается пробелами.
  * После `;` — пробел, а перед — нет пробела.
  * После `{` — перевод строки.

<!---->

    //  Плохо.
    for(i = 0;i < 10;i++){
        doSomething(i);
    }

    //  Плохо.
    for (i = 0; i < 10; i++) { doSomething(i); }

    //  Хорошо.
    for ( i = 0; i < 10; i++ ) {
        doSomething( i );
    }

Если переменные `i` и `l` не используются нигде, кроме тела цикла, то определяем их внутри:

    for ( var i = 0, l = a.length; i < l; i++ ) {
        ...
    }

    //  Плохо.
    //  Переменная `i` в этом месте не "определена".
    var j = i + 1;

Если же переменные цикла используются и за пределами блока, то определяем их отдельно:

    var i, l;

    for ( i = 0, l = a.length; i < l; i++ ) {
        ...
    }

    if ( i > 5 ) {
        ...
    }

При этом нормально определять и использовать одни и те же переменные внутри
нескольких циклов:

    for ( var i = 0, l = a.length; i < l; i++ ) {
        ...
    }

    //  Да, формально i и l в JavaScript'е тут уже определены,
    //  но мы притворяемся, что у нас блочный scope.
    for ( var i = 0, l = a.length; i < l; i++ ) {
        ...
    }


## Оператор `switch`

  * Между `switch` и `(` — пробел.
  * Между `)` и `{` — пробел.
  * Условие в `( ... )` отбивается пробелами.
  * После `{` — перевод строки.
  * Каждый `case` индентится, код для этого `case` еще индентится.
  * Между `case`-ами (или их группами) желательна пустая строка.
  * `break` на отдельной строке.

<!---->

    //  Плохо.
    switch(id){
        case 'first': doSomethingOne(); break;
        case 'second':
        case 'third': doSomethingTwo();
            break;
        default: doSomethingThree();
    }

    //  Хорошо.
    switch ( id ) {
        case 'first':
            doSomethingOne();
            break;

        case 'second':
        case 'third':
            doSomethingTwo();
            break;

        default:
            doSomethingThree();
    }


## Определение функции

### Именованная функция

  * Между `function` и именем функции — пробел (очевидно).
  * Между именем функции и `(` — нет пробела.
  * Между `)` и `{` — пробел.
  * Если функция без аргументов, то пробелов между `()` нет.
  * Если аргументы есть, то они отбиваются пробелами с обеих сторон.
  * После запятой — пробел, перед запятой пробела никогда нет.

<!---->

    function foo() {
        ...
    }

    function foo( x, y ) {
        ...
    }

### Анонимная функция

  * В случае анонимной функции, ключевое слово `function` в каком-то смысле выполняет роль имени,
    поэтому между `function` и `(` нет пробела:

<!---->

    function() {
        ...
    }

    function( x, y ) {
        ...
    }

Практически всегда после `{` должен быть перевод строки.
Даже если функция маленькая, лучше не делать ее однострочной.

    //  Не очень.
    foo( 'bar', function() { return true; } )

    function foo() { return true; }

    //  Хорошо.
    foo('bar', function() {
        return true;
    });

    function foo() {
        return true;
    }


## Определение переменных

Каждая переменная заслуживает своего личного `var`:

    //  Плохо.
    var i = 0,
        result = {},
        list = [];

    //  Хорошо.
    var i = 0;
    var result = {};
    var list = [];

Единственное исключение: набор однородных и связанных
(т.е. эти переменные для одного и того же и не могут использоваться порознь)
переменных, без инициализации. Например:

    var i, j, k;
    for ( i = 0; i < 10; i++ ) {
        for ( j = 0; j < 10; j++ ) {
            for ( k = 0; k < 10; k++ ) {
                ...

    var i, l;
    for ( i = 0, l = a.length; i < l; i++ ) {
        ...
    }

То есть более-менее это переменные для итерации.

Если переменные не связаны (даже если нет инициализации),
нужно использовать отдельные `var`:

    var id;
    var is_foo;

Не нужно выравнивать значения переменных в столбик:

    //  Плохо.
    var id =            42;
    var title =         'Hello';
    var is_something =  true;

    //  Плохо.
    var id              = 42;
    var title           = 'Hello';
    var is_something    = true;

    //  Хорошо.
    var id = 42;
    var title = 'Hello';
    var is_something = true;

Переменные определяются по месту использования, а не вначале scope'а.
При этом считаем, что у нас блочный scope (на самом деле в JavaScript это не так).

    //  Плохо.
    if (...) {
        var i = 10;
        ...

    }

    //  Ошибка!
    //  Запрещается использовать переменную вне блока,
    //  в котором она определена.
    var j = i + 1;


    //  Хорошо.
    var i;
    if (...) {
        i = 10;
        ...
    }

    var j = i + 1;


## Определение "классов"

    //  Конструктор.
    function Foo() {
        ...
    }

    /*
    //  Или же:
    var Foo = function() {
        ...
    };

    //  Или же
    ns.Foo = function() {

    };
    */

    //  Наследуемся, если нужно.
    inherit(Foo, Bar);

    //  Каждый метод/свойство определяется отдельно.

    Foo.prototype.id = 0;

    Foo.prototype.foo = function() {
        ...
    };


## Именование сущностей

### Константы

Используем `ALL_CAPS` стиль:

    var PI = 3.1415;
    var MAX_ID = 1000;

    //  В этом случае `no.View` это неймспейс,
    //  а `STATUS.OK` — название константы.
    //
    no.View.STATUS.OK = 'ok';

### Конструкторы

Название конструктора всегда начинается с заглавной буквы.
Используем Camel_Case:

    function View() {
        ...
    }

    function View_Collection() {
        ...
    }

### Приватные свойства и методы объекта

Используем префикс `_`:

    function Foo( data ) {
        this._data = data;
    }

    Foo.prototype._getData = function() {
        ...
    };

### Переменные

Используем `under_score_style`:

    var model_id = model.id;

    function get_model_id( model ) {
        return model.id;
    }

### Методы

Используем `camel_Case`:

    model.get_Data()

    this.build_HTML_Tree()

**FIXME:** Или же таки просто `under_score_style`:

    model.get_date();

    this.build_html_tree();

Надо еще подумать. Скорее второй вариант.

### `jQuery`-объекты

Используем префикс `$` для jquery-объектов:

    var $node = $( node );

Это позволяет нам избегать ошибок типа:

    $($node).find( ... )


## Комментарии

Желательно использовать инлайновые комментарии, а не блочные.
Причина простая: код, в котором есть блочные комментарии,
невозможно легко и просто закомментировать одним куском.
А инлайновые комментарии этому не мешают.

Комментарии всегда на отдельной строке.

    var i = 0; // Вот так ПЛОХО.

    //  Хорошо.
    //  Определяем переменную `i`.
    var i = 0;

После `//` добавляем **два** пробела.
Причина: комментарии в этом случае выравниваются "по сетке".
В комментариях используем `markdown`. Когда-нибудь будем использовать тулзу
для генерации из кода читаемой документации.

    //  Комментарий, относящийся к блоку кода.
    //  Чтобы комментарий (особенно многострочный) не прилипал впритык к коду,
    //  рекомендуется добавлять пустую строку-комментарий.
    //
    function a() {
        //  Поясняем конкретную строку.
        if ( x > 0 ) {
            ...
        }

        //  Коммент не привязанный к конкретному блоку кода.
        //  Отбивается сверху и снизу пустой строкой.

        //  Коммент про блок кода.
        //  Многострочный и многословный.
        //
        //  Считаем, что комментарии написаны с использованием `markdown`:
        //
        //      for ( var i = 0; i < 10; i++ ) {
        //          ...
        //      }
        //
        for ( var i = 0; i < 10; i++ ) {
            ...
        }
    }

Комментарий должен быть отдельным предложением (или несколькими предложениями) —
т.е. начинаться с заглавной буквы, заканчиваться точкой (обычно):

    //  Плохо.
    //  тут мы делаем что-то такое

    //  Хорошо.
    //  Тут мы делаем что-то такое.

Блочные комментарии всегда располагаем на отдельной строке.

    //  Плохо.
    /* function a() {
        ...
    } */

    /*
    //  Хорошо.
    function a() {
        ...
    }
    */

И лучше не использовать их вообще. Разве что чтобы закомментить быстро кусок кода.

### jsdocs

Еще приходится использовать блочные комментарии для jsdocs.
Хорошо бы была замена для jsdocs, использующая строчные комментарии.
В целом же я противнки jsdocs — не рассматриваю их как комментарии.
Это какие-то инструкции для роботов (для IDE и прочих автоматических штук),
а не для людей. Читать их невозможно, формат у них жуткий и громоздкий,
и они только загромождают код и отвлекают от него.


## Присваивания

  * `=` отбивается с двух сторон пробелами.
  * Каждое присваивание должно располагаться на отдельной строке:

<!---->

    //  Плохо.
    s='Hello'; i=0;

    //  Хорошо.
    s = 'Hello';
    i = 0;


## Присваивание выражения со сравнениями

Используем скобки, чтоб явно отделить выражение от присваивания:

    //  Плохо.
    var a = b > 0;
    var c = d === e;
    var x = y > 0 && z < 0;

    //  Хорошо.
    var a = ( b > 0 );
    var c = ( d === e );
    var x = ( y > 0 && z < 0 );

При этом можно писать и так:

    var is_foo = foo && bar;

и так:

    var is_foo = ( foo && bar );


## Присваивание в выражении

Не очень хорошая идея, но иногда бывает удобно использовать результат
присваивания в качестве выражения.
В этом случае присваивание оборачивается в `(( ... ))`.
Это говорит нам, что это не ошибка, что здесь не предполагается `==` или `===`,
а это явное присваивание:

    //  Плохо.
    if ( data = this.getData() ) {
        ...
    }

    //  Хорошо.
    if (( data = this.getData() )) {
        ...
    }


## Выражения

Все бинарные операции (сравнения, арифметические и т.д.) всегда отбиваются пробелами с двух сторон:

    if ( a == b || a > 1 ) {
        ...
    }

Все унарные операции (унарный минус, инкременты, и т.д.) никогда не отбиваются пробелами:

    if ( !a && -a < 3 || ~a ) {
        i++;
    }

Скобки добавляем, если выражение сложное и приоритеты не читаются сразу. Но без фанатизма:

    //  Плохо.
    var a = b || c && d > 0 || b == 0;

    //  Хорошо.
    var a = ( b || ( c && (d > 0) ) || (b == 0) );

При сравнении выражения с константой, слева — выражение, справа — константа.

    //  Плохо.
    if (1 == a && true !== f(a)) {
        ...
    }

    //  Хорошо.
    if ( a == 1 && f( a ) !== true ) {
        ...
    }


## Обращение к свойству объекта или элементу массива

Отбиваем содержимое `[ ... ]` пробелами с двух сторон:

    array[ 0 ]
    array[ i ]

    object[ 'foo' ]
    object[ id ]

**Спорно:** Наверное, в таких простых случаях, когда внутри `[...]` либо число,
либо идентификатор, либо строка, можно пробелы опустить:

    array[0]
    array[index]

    object['foo']
    object[key]

Но:

    array[ i + 1 ]
    array[ index() ]

    object[ 'id-' + id ]
    object[ get_id() ]


## `==` vs. `===`

Всегда используем `===`:

    //  Плохо.
    //  Даже несмотря на то, что результат `typeof` всегда `string`.
    if ( typeof s == 'string' ) {

    }

    if ( typeof s === 'string' ) {
        ...
    }

За исключением одного случая, когда нужно проверить, не является ли значение `null` или `undefined`.

    if ( value == null ) {
        //  value === null || value === undefined.
        ...
    }


## `typeof`, `instanceof`, ...

Как правило не нужны скобки вокруг аргументов этих операторов:

    //  Плохо.
    typeof (x) === 'string'
    (x) instanceof Array

    //  Хорошо.
    typeof x === 'string'
    x instanceof Array


## Тернарный оператор

Условие в скобках, вокруг `?` и `:` — пробелы:

    //  Плохо.
    var x = a > 0? 1 : 0;

    //  Хорошо.
    var x = ( a > 0 ) ? 1 : 0;

Вложенные тернарные операторы запрещены.

    //  Плохо.
    var r = (a > 0) ? (b > 0) ? a : b : 0;

    //  Хорошо.
    var t = ( b > 0 ) ? a : b;
    var r = ( a > 0 ) ? t : 0;

    //  Хорошо.
    var r;
    if ( a > 0 ) {
        r = ( b > 0 ) ? a : b;
    } else {
        r = 0;
    }

    //  Нормально.
    //  Хоть и громоздко, но читаемо.
    //
    var r;
    if ( a > 0 ) {
        if ( b > 0 ) {
            r = a;
        } else {
            r = b;
        }
    } else {
        r = 0;
    }

Пусть обфускатор с этим разбирается.


## `if` vs. тернарный оператор, `&&`, `||`

Да, JavaScript позволяет использовать тернарный оператор в качестве замены `if`:

    (a > 0) ? f() : g();

    (a > 0) && f();

    (a > 0) || g();

Но это **дурной тон**. Никогда-никогда так не делаем.

Не ленимся, не экономим байты и используем `if`:

    if ( a > 0 ) {
        f();
    } else {
        g();
    }

    if ( a > 0 ) {
        f();
    }

    if ( !( a > 0 ) ) {
        g();
    }

Правило очень простое.
Если блок не возвращает значение или же мы это значение игнорируем, то всегда используется `if`.
Тернарный оператор, `&&` и `||` могут использоваться как часть выражения, возвращаюшего значение:

    a = b && c;

    if ( ( a > 0 ) || ( b < 0 ) ) {
        ...
    }

    x = ( y > 0 ) ? 42 : z();

Т.е., грубо говоря, выражения, участвующие в `&&`, `||`, `?:` должны быть без side effects.


## Вызов функции

  * Между именем функции и `(` нет пробела.
  * Если параметры не передаются, то между `()` пробелов нет.
  * Если параметры есть, то они отбиваются пробелами.
  * После запятой есть пробел, перед — нет.

<!---->

    foo()
    bar( x, y )

    foo( bar( x ), bar( y, quu( z ) ) )

Если в одной строчке слишком много вложенных вызовов,
то можно это как-то переформатировать:

    var t = bar( y, quu( z ) );
    foo( bar( x ), t );

    //  Или.
    foo(
        bar( x ),
        bar( y, quu( z ) )
    );

Object-литерал в качестве параметра:

    foo( { foo: 42, bar: 24 } )
    foo( x, { foo: 42, bar: 24 } )
    foo( { foo: 42, bar: 24 }, x )

    foo( {
        foo: 42,
        bar: 24
    } )

    foo( x, {
        foo: 42,
        bar: 24
    } )

    foo( {
        foo: 42,
        bar: 24
    }, x )

Array-литерал аналогично:

    foo( [ 1, 2, 3 ] )
    foo( [ 1, 2, 3 ], x )
    foo( x, [ 1, 2, 3 ] )

    foo( [
        1,
        2,
        3
    ] )

    foo( x, [
        1,
        2,
        3
    ] )

    foo( [
        1,
        2,
        3
    ], x )

Функция в качестве параметра (аналогично):

    foo( function() {
        ...
    } )

    this.foo( 'bar', function() {
        ...
    }, true )


Если в функцию передается несколько длинных выражений,
то лучше каждое разместить на отдельной строке:

    foo(
        first_long_argument,
        second_long_argument,
        third_long_argument
    )

Если есть несколько многострочных параметров,
то лучше каждый разместить на отдельной строке с индентом:

    //  Плохо.
    this.then( function() {
        ...
    }, function() {
        ...
    } );

    foo( {
        foo: 42
    }, {
        bar: 24
    } );

    //  Хорошо.
    this.then(
        function() {
            ...
        },
        function() {
            ...
        }
    );

    foo(
        {
            foo: 42
        },
        {
            bar: 24
        }
    );


## Chaining

Chain-вызовы в количестве больше двух быстро
превращают код в нечитаемую кашу.
Каждый вызов лучше расположить на отдельной строки,
начинающейся с точки.

    //  Плохо.
    function quote(s) {
        return s.toString().replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    //  Лучше, но все равно плохо.
    function quote(s) {
        return s.toString().replace(/&/g, '&amp;')
            .replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    //  Хорошо.
    function quote( s ) {
        return s
            .toString()
            .replace( /&/g, '&amp;' )
            .replace( /</g, '&lt;' )
            .replace( />/g, '&gt;' );
    }


## Object literal

В однострочном объекте отбиваем содержимое от скобок пробелом.
После двоеточия всегда пробел, перед — нет пробела.

    //  Плохо.
    {id : 42, title : 'Hello'}

    //  Хорошо.
    { id: 42, title: 'Hello' }

Многострочный объект. Запятая в конце строки.

    {
        id: 42,
        title: 'Hello'
    }

Никогда не выравниваем значения в столбик:

    //  Плохо.
    {
        id:     42,
        title:  'Hello'
    }

(Спорно) В случае, когда некоторые ключи нужно кавычить, лучше делать это для всех ключей.
Даже для тех, для которых это не нужно:

    //  Не очень хорошо.
    {
        id: 42,
        'category-id': 'life',
        'post-title': 'Hello'
    }

    //  Лучше.
    {
        'id': 42,
        'category-id': 'life',
        'post-title': 'Hello'
    }


## Array literal

В однострочном массиве отбиваем содержимое от скобок пробелом.
После запятой всегда пробел, перед запятой нет пробела:

    //  Плохо.
    [1,2,3]

    //  Хорошо.
    [ 1, 2, 3 ]

Многострочный массив:

    [
        1,
        2,
        3
    ]

В многострочном массиве каждое значение на отдельной строке:

    //  Не очень хорошо.
    [
        1, 2, 3,
        4,
        5
    ]

Но возможен вариант а-ля матрица:

    [
        1, 2, 3,
        4, 5, 6,
        7, 8, 9
    ]


## Не определять методы внутри object literal

    //  Плохо.
    var obj = {
        getData: function() {
            return this.data;
        },
        ...
    };

    //  Хорошо.
    var obj = {};

    obj.getData = function() {
        return this.data;
    };

Тоже самое, при использовании разных фабрик объектов:

    //  Плохо.
    ns.View.define( 'message', {
        events: {
            'changed': function() {
                ...
            },
            ...
        },

        methods: {
            'onclick': function() {
                ...
            },
            ...
        }
    } );


    //  Хорошо.
    var events = {};

    events.changed = function() {
        ...
    };

    var methods = {};

    methods.onclick = function() {
        ...
    };

    ns.View.define( 'message', {
        events: events,
        methods: methods
    } );


    //  Еще лучше.
    var message = {};

    message.events = {};

    message.events.changed = function() {
        ...
    };

    message.methods = {};

    message.methods.onclick = function() {
        ...
    };

    ns.View.define( 'message', message );


## `var that = this;`

Стандартный "заменитель" для `this` — `that`:

    var that = this;

    doAsync( function() {
        that.doSomething();
    } );


## Immediately-Invoked Function Expression (IIFE)

Используется для явного создания замыканий и для обертки модулей:

    ( function() {
        ...
    } )();

    ( function( x, y ) {
        ...
    } )( foo(), bar() );


## Обертка для модуля

Часто весь модуль заворачивается в `IIFE`,
чтобы не засорять глобальный контекст:

    //  Неймспейс.
    var ns = {};

    ( function() {

    //  ---------------------------------------------------------------------------------------------------------------  //

    //  Глобальные переменные модуля,
    //  которые не должны засорять общий глобальный контекст.
    //
    var id = 42;

    ns.foo = function() {
        ...
    }

    //  ---------------------------------------------------------------------------------------------------------------  //

    } )();

При этом содержимое модуля не индентится.
Только в этом случае — когда это на самом верхнем уровне файла.

Вот здесь уже должен быть индент,
т.к. здесь это не wrapper модуля, а просто обертка для замыкания:

    var results = [];
    for (var i = 0; i < 10; i++) {
        ( function(i) {
            //  Должен быть индент.
            get( function( result ) {
                results[ i ] = result;
            } );
        } )( i );
    }


## Шоткаты в модуле

Не используем шоткаты!

    //  Плохо.

    //  Глобальный неймспейс.
    var ns = ns || {};

    (function() {

        function Foo() {
            ...
        }

        Foo.prototype.foo = function() {
            ...
        };

        ns.Foo = Foo;

        //  Т.е.`Foo` это шоткат к `ns.Foo` внутри модуля.

    })();

    //  Плохо.

    var ns = ns || {};

    (function() {

        function Bar() {
            ...
        };

        Bar.prototype.bar = function() {

        };

        ns.foo = {};
        ns.foo.Bar = Bar;

        //  Т.е. `Bar` это шоткат к `ns.foo.Bar` внутри модуля.

    })();

    //  Плохо.

    var ns = ns || {};

    (function() {

        var bar = ns.foo.bar;

        bar.Bar = function() {
            ...
        };

        bar.Bar.prototype.quu = function() {
            ...
        };

        //  Т.е. `bar` это шоткат к `ns.foo.bar`.

    })();

Всегда явно указывает полный путь определяемых функций, классов и т.д.:

    //  Хорошо.

    var ns = ns || {};

    (function() {

        ns.Foo = function() {
            ...
        }

        ns.Foo.prototype.foo = function() {
            ...
        };

    })();

    //  Хорошо.

    var ns = ns || {};

    (function() {

        ns.foo = {};

        ns.foo.Bar = function() {
            ...
        };

        ns.foo.Bar.prototype.bar = function() {

        };

    })();

    //  Хорошо.

    var ns = ns || {};

    (function() {

        ns.foo.bar.Bar = function() {
            ...
        };

        ns.foo.bar.Bar.prototype.quu = function() {
            ...
        };

    })();

Почему я против шоткатов? Они не позволяют быстро грепать код, не позволяют по одной строчке
понять, что именно нашлось. Сравните (типа результат `grep Bar`):

    function Bar() {
и
    ns.foo.Bar = function() {

В последнем варианте видно и неймспейс, и поднеймспейс, и класс и все, что нужно.

По тем же причинам я против определения методов внутри object literal. Там еще сильнее разница:

    isValid: function() {
и
    ns.View.prototype.isValid = function() {


## Кавычки

Всегда используем одинарные кавычки:

    // Во-первых, удобнее набирать — не нужно нажимать шифт.
    var msg = 'Hello, World!';

    // Во-вторых, в html'ных (xml'ных, json'ных) фрагментах можно использовать двойные кавычки и не эскейпить их.
    //
    var html = '<div class="hello">Hello, World</div>';
    var json = '{ "foo": 42, "bar": "Hello" }';


## HRule

Для визуального разбиения кода на части используется вот такой разделитель:

    function foo() {
        ...
    }

    //  ---------------------------------------------------------------------------------------------------------------  //

    function bar() {
        ...
    }

Его длина — 119 символов (не спрашивайте).
Обратите внимание, по два пробела после и перед `//`.

Сверху и снизу отбивается пустой строкой.

Можно использовать для "заголовков", начинающих большую секцию кода:

    //  ---------------------------------------------------------------------------------------------------------------  //
    //  ns.View
    //  ---------------------------------------------------------------------------------------------------------------  //

    ns.View = function() {
        ...
    };

    //  ---------------------------------------------------------------------------------------------------------------  //

    ns.View.prototype.foo = function() {
        ...
    };

    ns.View.prototype.bar = function() {
        ...
    };



    //  ---------------------------------------------------------------------------------------------------------------  //

Внутри секции используется опять-таки разделитель, а перед последним стоит не одна пустая строка,
а две-три, чтобы подчеркнуть, что секция тут заканчивается.


# Не синтаксический styleguide

Пока что в процессе.
Все, что выше — было про синтаксис, про пробелы, скобки, переводы строк и т.д.

Еще должно быть что-то про содержательную часть.


## Где можно использовать `this`

  * В методах объектов, инстанцированных через `new Foo()`,
    где `Foo` это конструктор.

    Например, вот здесь нельзя использовать `this`:

        //  `o` не является инстансом какого-либо класса.
        var o = {};

        o.id = 42;

        o.get_id = function() {
            return this.id;
        };

  * Например, в случае, когда к объекту примиксован интерфейс подписки на события
    и обработчики событий вызываются в контексте этого объекта:

        view.on( 'init', function() {
            this.doSomething();
        } );

        view.trigger( 'init' );

    Тут важный, но сложный, момент. Эти методы должны вызываться со сменой контекста централизовано,
    специально написанным кодом. Например, метод `trigger` — такое место.

    Вот такой вариант не годится:

        function foo() {
            this.doSomething();
        }

        foo.call(view);

    Грубо говоря, `call/apply` могут быть в "библиотечном" коде и тогда в "юзерском" коде
    могут быть функции/методы, использующие `this`.
    Но в "юзерском" коде никаких `call/apply` быть не должно.


## По возможности не использовать `call` и `apply`

См. предыдущий пункт.

Следует избегать принудетельной смены контекста при вызове функций.
Это сильно затрудняет понимание кода, т.к. из кода такой функции непонятно,
а что же там будет в `this`:

    function foo() {
        //  Что такое `this` здесь?
        return this.foo;
    }

Вот тут понятно:

    Foo.prototype.foo = function() {
        return this.foo;
    };

Вот тут более-менее понятно:

    ns.View.define('foo', {
        events: {
            'click': function() {
                this.doSomething();
            }
        }
    });


## Не использовать `bind`

Придерживаюсь мнения, что `bind` — это страшное зло.

См. предыдущие два пункта.
Напишу больше потом.



