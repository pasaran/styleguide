# Styleguide для JavaScript'а

Основное положение: экономить байты в коде должен обфускатор,
а код должен быть максимально читаемым и понятным.


## Общие положения

  * Кодировка файлов — utf-8;

  * Переводы строк — unix style;

  * Индент — 4 пробела;

  * Не забываем удалять "висящие" пробелы, т.е. те, после которых нет непробельных символов.

  * Всегда явно ставим `;`, не полагаясь на automatic semicolon insertion.


## Спорные вещи

Есть кое-какие моменты, которые я почти готов внести в styleguide, даже несмотря на то,
что мне пока не очень нравятся эти изменения. Или не до конца нравятся.

В частности:

  * Использовать `under_score_style` для всех переменных и функций.
    Для конструкторов — `Under_Score_Style`.
    Для методов — `under_Score_Style` (хотя, возможно, и просто `under_score_style`).

    Причина. Подчеркивание намного более читаемо в качестве разделителя слов.
    Слова в `camelCase` и `CamelCase` сливаются в кашу.

    Сравните:

        'getElementById'        'get_element_by_id'         'get_Element_By_Id'
        'buildHTMLTree'         'build_html_tree'           'build_HTML_Tree'

    Да, подчеркивание непривычно (для javascript'а, хотя вполне привычно в C).
    Но зато решает задачу читаемости.

  * Всегда отбивать пробелами изнутри круглые скобки:

        if ( x ) {
            ...
        }

        foo( x, y )

    Причина. Текущее правило таково, что отбивка нужна, если внутри скобок есть другие скобки.
    (более мягкий вариант, если есть рядом стоящие скобки, например '))' или '])' и т.д.

        //  Плохо.
        foo(bar(), quu())

        //  Хорошо.
        foo( bar(), quu() )

    Но. Предположим, что у нас есть такой код:

        foo(x, y)

    Раз внутри скобок нет, то вроде отбивка не нужна.
    Но вот мы решили добавить еще аргумент (или поменять существующий):

        foo(x, y, z() )

    Потом приходится идти к первой скобке и ставить пробел там.
    Кажется, что лучше сразу ставить пробелы везде и не мучиться потом.
    Опять-таки непривычно, но консистентно.


## Блоки кода `{...}`

Открывающая `{` расположена на той же строке, что и оператор, к которому она относится.

    //  Плохо:
    if ( ... )
    {
        ...
    }

    //  Хорошо:
    if ( ... ) {
        ...
    }

Закрывающая `}` выровнена по открывающему оператору (внутренняя по `while`, внешняя по `if` в данном случае):

    if ( ... ) {
        while ( ... ) {
            ...
        }
    }

Перед открывающей `{` всегда ставится пробел.

Однострочные блоки кода почти всегда запрещены:

    //  Плохо.
    while ( i < 10 ) { doSomething( i ); }

    //  Хорошо.
    while ( i < 10 ) {
        doSomething( i );
    }

Единственное исключение:

    ... { return; }
    ... { continue; }
    ... { break; }


## Оператор `if`

  * Между `if` и `(` — пробел.
  * Между `)` и `{` — пробел.
  * Выражение внутри `( ... )` отбито пробелами.

<!---->

    //  Плохо.
    if(i > 0){
        ...
    }

    //  Хорошо.
    if ( i > 0 ) {
        ...
    }

Тело `if` всегда в фигурных скобках:

    //  Плохо.
    if ( ... ) doSomething();
    if ( ... ) return;

    //  Хорошо.
    if ( ... ) {
        doSomething();
    }
    if ( ... ) { return; }

После `{` почти всегда должен быть перевод строки.
Допустимые исключения:

    //  Можно.
    if ( ... ) { return; }
    if ( ... ) { continue; }
    if ( ... ) { break; }

    //  Плохо.
    if ( ... ) { doSomething(); }

Однострочный `if` с `else` запрещен в любых ситуациях:

    //  Плохо.
    if ( ... ) { first(); } else { second(); }

    //  Хорошо.
    if ( ... ) {
        first();
    } else {
        second();
    }

`else` на той же строке, что и `}` первого блока, перед `else` — пробел, перед `{` — пробел:

    //  Плохо.
    if ( ... ) {
        ...
    }
    else {
        ...
    }

    //  Хорошо.
    if ( ... ) {
        ...
    } else {
        ...
    }

`else if` оформляется по тем же правилам, что и `else`:

    if ( ... ) {
        ...
    } else if ( ... ) {
        ...
    }

    if ( ... ) {
        ...
    } else if ( ... ) {
        ...
    } else if ( ... ) {
        ...
    } else {
        ...
    }


## Оператор `while`

  * Между `while` и `(` — пробел.
  * Между `)` и `{` — пробел.
  * Выражение в `( ... )` отбивается пробелами.
  * После `{` — перевод строки.

<!---->

    //  Плохо.
    while(i < 10){
        doSomething(i);
    }

    //  Плохо.
    while ( i < 10 ) { doSomething( i ); }

    //  Хорошо.
    while ( i < 10 ) {
        doSomething( i );
    }


## Цикл `do`

  * Между `do` и `{` — пробел.
  * Между `}` и `while` — пробел.
  * Между `while` и `(` — пробел.
  * Выражение в `( ... )` отбивается пробелами.
  * После `{` — перевод строки.

<!---->

    //  Плохо.
    do{
        doSomething(i++);
    }while(i < 10);

    do { doSomething(i++); } while ( i < 10 );

    //  Хорошо.
    do {
        doSomething( i++ );
    } while ( i < 10 );

Вообще говоря, я предпочитаю не пользоваться этим циклом вообще.
Мне больше нравится более явный цикл `while`:

    while ( true ) {
        doSomething( i++ );

        if ( i >= 10 ) { break; }
    }


## Оператор `for`

  * Между `for` и `(` — пробел.
  * Между `)` и `{` — пробел.
  * Содержимое внутри `( ... )` отбивается пробелами.
  * После `;` — пробел, а перед — нет пробела.
  * После `{` — перевод строки.

<!---->

    //  Плохо.
    for(i = 0;i < 10;i++){
        doSomething(i);
    }

    //  Плохо.
    for (i = 0; i < 10; i++) { doSomething(i); }

    //  Хорошо.
    for ( i = 0; i < 10; i++ ) {
        doSomething( i );
    }

Если переменные `i` и `l` не используются нигде, кроме тела цикла, то определяем их внутри:

    for ( var i = 0, l = a.length; i < l; i++ ) {
        ...
    }

    //  Плохо.
    //  Переменная `i` в этом месте не "определена".
    var j = i + 1;

Если же переменные цикла используются и за пределами блока, то определяем их отдельно:

    var i, l;

    for ( i = 0, l = a.length; i < l; i++ ) {
        ...
    }

    if ( i > 5 ) {
        ...
    }

При этом нормально определять и использовать одни и те же переменные внутри
нескольких циклов:

    for ( var i = 0, l = a.length; i < l; i++ ) {
        ...
    }

    //  Да, формально i и l в JavaScript'е тут уже определены,
    //  но мы притворяемся, что у нас блочный scope.
    for ( var i = 0, l = a.length; i < l; i++ ) {
        ...
    }


## Оператор `switch`

  * Между `switch` и `(` — пробел.
  * Между `)` и `{` — пробел.
  * Условие в `( ... )` отбивается пробелами.
  * После `{` — перевод строки.
  * Каждый `case` индентится, код для этого `case` еще индентится.
  * Между `case`-ами (или их группами) желательна пустая строка.
  * `break` на отдельной строке.

<!---->

    //  Плохо.
    switch(id){
        case 'first': doSomethingOne(); break;
        case 'second':
        case 'third': doSomethingTwo();
            break;
        default: doSomethingThree();
    }

    //  Хорошо.
    switch ( id ) {
        case 'first':
            doSomethingOne();
            break;

        case 'second':
        case 'third':
            doSomethingTwo();
            break;

        default:
            doSomethingThree();
    }


## Определение функции

### Именованная функция

  * Между `function` и именем функции — пробел (очевидно).
  * Между именем функции и `(` — нет пробела.
  * Между `)` и `{` — пробел.
  * Если функция без аргументов, то пробелов между `()` нет.
  * Если аргументы есть, то они отбиваются пробелами с обеих сторон.
  * После запятой — пробел, перед запятой пробела никогда нет.

<!---->

    function foo() {
        ...
    }

    function foo( x, y ) {
        ...
    }

### Анонимная функция

  * В случае анонимной функции, ключевое слово `function` в каком-то смысле выполняет роль имени,
    поэтому между `function` и `(` нет пробела:

<!---->

    function() {
        ...
    }

    function( x, y ) {
        ...
    }

Практически всегда после `{` должен быть перевод строки.
Даже если функция маленькая, лучше не делать ее однострочной.

    //  Не очень.
    foo( 'bar', function() { return true; } )

    function foo() { return true; }

    //  Хорошо.
    foo('bar', function() {
        return true;
    });

    function foo() {
        return true;
    }


## Определение переменных

Каждая переменная заслуживает своего личного `var`:

    //  Плохо.
    var i = 0,
        result = {},
        list = [];

    //  Хорошо.
    var i = 0;
    var result = {};
    var list = [];

Единственное исключение: набор однородных и связанных
(т.е. эти переменные для одного и того же и не могут использоваться порознь)
переменных, без инициализации. Например:

    var i, j, k;
    for (i = 0; i < 10; i++) {
        for (j = 0; j < 10; j++) {
            for (k = 0; k < 10; k++) {
                ...

    var i, l;
    for (var i = 0, l = a.length; i < l; i++) {
        ...
    }

То есть более-менее это переменные для итерации.

Если переменные не связаны (даже если нет инициализации),
нужно использовать отдельные `var`:

    var id;
    var is_foo;

Не нужно выравнивать значения переменных в столбик:

    //  Плохо.
    var id =            42;
    var title =         'Hello';
    var is_something =  true;

    //  Плохо.
    var id              = 42;
    var title           = 'Hello';
    var is_something    = true;

    //  Хорошо.
    var id = 42;
    var title = 'Hello';
    var is_something = true;

Переменные определяются по месту использования, а не вначале scope'а.
При этом считаем, что у нас блочный scope (на самом деле в JavaScript это не так).

    //  Плохо.
    if (...) {
        var i = 10;
        ...

    }

    //  Ошибка!
    //  Запрещается использовать переменную вне блока,
    //  в котором она определена.
    var j = i + 1;


    //  Хорошо.
    var i;
    if (...) {
        i = 10;
        ...
    }

    var j = i + 1;


## Определение "классов"

    //  Конструктор.
    function Foo() {
        ...
    }

    /*
    //  Или же:
    var Foo = function() {
        ...
    };

    //  Или же
    ns.Foo = function() {

    };
    */

    //  Наследуемся, если нужно.
    inherit(Foo, Bar);

    //  Каждый метод/свойство определяется отдельно.

    Foo.prototype.id = 0;

    Foo.prototype.foo = function() {
        ...
    };


## Именование сущностей

### Константы

Используем `ALL_CAPS` стиль:

    var PI = 3.1415;
    var MAX_ID = 1000;

    //  В этом случае `no.View` это неймспейс,
    //  а `STATUS.OK` — название константы.
    //
    no.View.STATUS.OK = 'ok';

### Конструкторы

Название конструктора всегда начинается с заглавной буквы.
Используем Camel_Case:

    function View() {
        ...
    }

    function View_Collection() {
        ...
    }

### Приватные свойства и методы объекта

Используем префикс `_`:

    function Foo(data) {
        this._data = data;
    }

    Foo.prototype._getData = function() {
        ...
    };

### Переменные

Используем `under_score_style`.

    var model_id = model.id;

### Методы

Используем `camel_Case`:

    model.get_Data()

    this.build_HTML_Tree()

### `jQuery`-объекты

Используем префикс `$` для jquery-объектов:

    var $node = $(node);

Это позволяет нам избегать ошибок типа:

    $($node).find(...)


## Комментарии

Желательно использовать инлайновые комментарии, а не блочные.
Причина простая: код, в котором есть блочные комментарии,
невозможно легко и просто закомментировать.
А инлайновые комментарии этому не мешают.

Комментарии всегда на отдельной строке.

    var i = 0; // Вот так ПЛОХО.

После `//` добавляем **два** пробела.
Причина: комментарии в этом случае выравниваются "по сетке".
В комментариях используем `markdown`.

    //  Комментарий, относящийся к блоку кода.
    //  Чтобы комментарий (особенно многострочный) не прилипал впритык к коду,
    //  рекомендуется добавлять пустую строку-комментарий.
    //
    function a() {
        //  Поясняем конкретную строку.
        if (x > 0) {
            ...
        }

        //  Коммент не привязанный к конкретному блоку кода.
        //  Отбивается сверху и снизу пустой строкой.

        //  Коммент про блок кода.
        //  Многострочный и многословный.
        //
        //  Считаем, что комментарии написаны с использованием `markdown`:
        //
        //      for (var i = 0; i < 10; i++) {
        //          ...
        //      }
        //
        for (var i = 0; i < 10; i++) {
            ...
        }
    }

Блочные комментарии всегда располагаем на отдельной строке.

    //  Плохо.
    /* function a() {
        ...
    } */

    /*
    //  Хорошо.
    function a() {
        ...
    }
    */

И лучше не использовать их вообще. Разве что чтобы закомментить быстро кусок кода.

Еще приходится использовать блочные комментарии для jsdocs.
Хорошо бы была замена для jsdocs, использующая строчные комментарии.


## Присваивания

`=` отбивается с двух сторон пробелами.
Каждое присваивание должно располагаться на отдельной строке:

    //  Плохо.
    s='Hello'; i=0;

    //  Хорошо.
    s = 'Hello';
    i = 0;


## Присваивание выражения со сравнениями

Используем скобки, чтоб явно отделить выражение от присваивания:

    //  Плохо.
    var a = b > 0;
    var c = d === e;
    var x = y > 0 && z < 0;

    //  Хорошо.
    var a = (b > 0);
    var c = (d === e);
    var x = (y > 0 && z < 0);

При этом можно писать и так:

    var is_foo = foo && bar;

и так:

    var is_foo = (foo && bar);


## Выражения

Все бинарные операции (сравнения, арифметические и т.д.) всегда отбиваются пробелами с двух сторон:

    var a = 1;

    if (a == b || a > 1) {
        ...
    }

Все унарные операции (унарный минус, инкременты, и т.д.) никогда не отбиваются пробелами:

    if (!a && -a < 3 || ~a) {
        i++;
    }

Скобки добавляем, если выражение сложное и приоритеты не читаются сразу. Но без фанатизма:

    //  Плохо.
    var a = b || c && d > 0 || b == 0;

    //  Хорошо.
    var a = ( b || ( c && (d > 0) ) || (b == 0) );

При сравнении выражения с константой, слева — выражение, справа — константа.

    //  Плохо.
    if (1 == a && true !== f(a)) {
        ...
    }

    //  Хорошо.
    if (a == 1 && f(a) !== true) {
        ...
    }


## `==` vs. `===`

Всегда используем `===`:

    if (typeof obj === "string") {
        ...
    }

За исключением одного случая, когда нужно проверить, не является ли значение `null` или `undefined`.

    if (value == null) {
        //  value === null || value === undefined.
        ...
    }


## Тернарный оператор

Условие в скобках, вокруг `?` и `:` — пробелы:

    var x = (a > 0) ? 1 : 0;

Вложенные тернарные операторы запрещены.

    //  Плохо.
    var r = (a > 0) ? (b > 0) ? a : b : 0;

    //  Хорошо.
    var r;
    if (a > 0) {
        r = (b > 0) ? a : b;
    } else {
        r = 0;
    }

    //  Хорошо.
    var r;
    if (a > 0) {
        if (b > 0) {
            r = a;
        } else {
            r = b;
        }
    } else {
        r = 0;
    }

Да, многословно, зато читаемо без вопросов.

    //  Хорошо.
    //  Вычисляем что-то там.
    var t = (b > 0) ? a : b;
    var r = (a > 0) ? t : 0;


## `if` vs. тернарный оператор, `&&`, `||`

Да, JavaScript позволяет использовать тернарный оператор в качестве замены `if`:

    (a > 0) ? f() : g();

    (a > 0) && f();

    (a > 0) || g();

Но это **дурной тон**. Никогда-никогда так не делаем.

Не ленимся, не экономим байты и используем `if`:

    if (a > 0) {
        f();
    } else {
        g();
    }

    if (a > 0) {
        f();
    }

    if (!(a > 0)) {
        g();
    }

Правило очень простое.
Если блок не возвращает значение или же мы это значение игнорируем, то всегда используется `if`.
Тернарный оператор, `&&` и `||` могут использоваться как часть выражения, возвращаюшего значение:

    a = b && c;
    b = (a > 0) || true;
    c = (a > 0) ? 2 : f();


## Вызов функции

Между именем функции и `(` нет пробела.

    var a = f(1, 2) + g();




## Кавычки

Всегда используем одинарные кавычки:

    // Во-первых, удобнее набирать — не нужно нажимать шифт.
    var msg = 'Hello, World!';

    // Во-вторых, в html'ных фрагментах можно использовать двойные кавычки и не эскейпить их.
    var html = '<div class="hello">Hello, World</div>';



## Не определять методы внутри object literal

    //  Плохо.
    var obj = {
        getData: function() {
            return this.data;
        },
        ...
    };

    //  Хорошо.
    var obj = {};

    obj.getData = function() {
        return this.data;
    };

Тоже самое, при использовании разных фабрик объектов:

    //  Плохо.
    ns.View.define('message', {
        events: {
            'changed': function() {
                ...
            },
            ...
        },

        methods: {
            'onclick': function() {
                ...
            },
            ...
        }
    });


    //  Хорошо.
    var events = {};

    events.changed = function() {
        ...
    };

    var methods = {};

    methods.onclick = function() {
        ...
    };

    ns.View.define('message', {
        events: events,
        methods: methods
    });


    //  Еще лучше.
    var message = {};

    message.events = {};

    message.events.changed = function() {
        ...
    };

    message.methods = {};

    message.methods.onclick = function() {
        ...
    };

    ns.View.define('message', message);

## `var that = this;`

Стандартный "заменитель" для `this` — `that`:

    var that = this;

    doAsync(function() {
        that.doSomething();
    });


## Не использовать `bind`

## По возможности не использовать `call` и `apply`

## Object literal

В однострочном объекте отбиваем содержимое от скобок пробелом.
После двоеточия всегда пробел, перед — нет пробела.

    //  Плохо.
    {id: 42, title: 'Hello'}

    //  Хорошо.
    { id: 42, title: 'Hello' }

Многострочный объект. Запятая в конце строки.

    {
        id: 42,
        title: 'Hello'
    }

Никогда не выравниваем значения в столбик:

    //  Плохо.
    {
        id:     42,
        title:  'Hello'
    }

(Спорно) В случае, когда некоторые ключи нужно кавычить, лучше делать это для всех ключей.
Даже для тех, для которых это не нужно:

    //  Не очень хорошо.
    {
        id: 42,
        'category-id': 'life',
        'post-title': 'Hello'
    }

    //  Лучше.
    {
        'id': 42,
        'category-id': 'life',
        'post-title': 'Hello'
    }


## Array literal

В однострочном массиве отбиваем содержимое от скобок пробелом.
После запятой всегда пробел, перед запятой нет пробела:

    //  Плохо.
    [1, 2, 3]

    //  Хорошо.
    [ 1, 2, 3 ]

Многострочный массив:

    [
        1,
        2,
        3
    ]

В многострочном массиве каждое значение на отдельной строке:

    //  Не очень хорошо.
    [
        1, 2, 3,
        4,
        5
    ]

Но возможен вариант а-ля матрица:

    [
        1, 2, 3,
        4, 5, 6,
        7, 8, 9
    ]

## Присваивание в выражении

Не очень хорошая идея, но иногда бывает удобно использовать результат
присваивания в качестве выражения.
В этом случае присваивание оборачивается в `(( ... ))`.
Это говорит нам, что это не ошибка, что здесь не предполагается `==`,
а это явное присваивание:

    //  Плохо.
    if ( data = this.getData() ) {
        ...
    }

    //  Хорошо.
    if (( data = this.getData() )) {
        ...
    }


## Chaining

    function quote(s) {
        return s
            .toString()
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
    }

## HRule

Для визуального разбиения кода на части используется вот такой разделитель:

    function foo() {
        ...
    }

    //  ---------------------------------------------------------------------------------------------------------------  //

    function bar() {
        ...
    }

Его длина — 119 символов (не спрашивайте).
Обратите внимание, по два пробела после и перед `//`.

Сверху и снизу отбивается пустой строкой.

Можно использовать для "заголовков", начинающих большую секцию кода:

    //  ---------------------------------------------------------------------------------------------------------------  //
    //  ns.View
    //  ---------------------------------------------------------------------------------------------------------------  //

    ns.View = function() {
        ...
    };

    //  ---------------------------------------------------------------------------------------------------------------  //

    ns.View.prototype.foo = function() {
        ...
    };

    ns.View.prototype.bar = function() {
        ...
    };



    //  ---------------------------------------------------------------------------------------------------------------  //

Внутри секции используется опять-таки разделитель, а перед последним стоит не одна пустая строка,
а две-три, чтобы подчеркнуть, что секция тут заканчивается.

## Обертка для модуля

Часто весь модуль заворачивается в `IIFE`,
чтобы не засорять глобальный контекст:

    //  Неймспейс.
    var ns = {};

    (function() {

    //  ---------------------------------------------------------------------------------------------------------------  //

    //  Глобальные переменные модуля,
    //  которые не должны засорять общий глобальный контекст.
    //
    var id = 42;

    ns.foo = function() {
        ...
    }

    //  ---------------------------------------------------------------------------------------------------------------  //

    })();

При этом содержимое модуля не индентится.
Только в этом случае — когда это на самом верхнем уровне файла.

Вот здесь уже должен быть индент, т.к. здесь это не wrapper модуля, а просто обертка для замыкания:

    var results = [];
    for (var i = 0; i < 10; i++) {
        (function(i) {
            //  Должен быть индент.
            get(function(result) {
                results[i] = result;
            });
        })(i);
    }

## IIFE

    (function(x) {
        ...
    })(42);

## Скобки и пробелы

    foo(i, j)
    foo(1, 2, 3, true, null)

    foo[0]
    foo[i]

    if (i * j % 1) {

    }

    while (i < 10) {

    }

    while ( foo(i) < 0 ) {

    }

## Вызов функции

    foo(1, 2, 3)

    foo( bar(), quu() )
    foo( bar(), 1, 2 )

    foo( { foo: 42, bar: 24 } )
    foo( [ 1, 2, 3 ] )

    foo({
        foo: 42,
        bar: 24
    })
    foo([
        1,
        2,
        3
    ])

    foo(
        first_long_argument,
        second_long_argument,
        third_long_argument
    )

    foo(function() {
        ...
    })

    this.foo('bar', function() {
        ...
    }, true);

    //  Плохо.
    this.then(function() {
        ...
    }, function() {
        ...
    })

    //  Хорошо.
    this.then(
        function() {
            ...
        },
        function() {
            ...
        }
    )

##

    x = (
        first() &&
        second() &&
        third()
    );

